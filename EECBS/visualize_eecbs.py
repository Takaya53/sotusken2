#!/usr/bin/env python3# -*- coding: utf-8 -*-import argparse, re, sysimport matplotlib.pyplot as pltimport matplotlib.animation as animationfrom pathlib import Path# ---------- Loading ----------def load_movingai_map(path, obstacles='@'):    H=W=None; grid=[]    lines = Path(path).read_text(encoding='utf-8', errors='ignore').splitlines()    for i,ln in enumerate(lines):        s=ln.strip().lower()        if s.startswith('height'): H=int(ln.split()[-1])        if s.startswith('width'):  W=int(ln.split()[-1])        if s=='map':            grid = lines[i+1:i+1+H]; break    if H is None or W is None or len(grid)!=H or any(len(r)!=W for r in grid):        sys.exit(f"[ERR] bad MovingAI header or grid size (H={H}, W={W})")    obs = {(x,y) for y,row in enumerate(grid) for x,c in enumerate(row) if c in obstacles}    return W,H,obspat_line  = re.compile(r'^Agent\s+(\d+):\s*(.*)$')pat_point = re.compile(r'\(\s*(\d+)\s*,\s*(\d+)\s*\)')def load_eecbs_paths(path):    agents=[]    for ln in Path(path).read_text(encoding='utf-8', errors='ignore').splitlines():        m = pat_line.match(ln.strip())        if not m: continue        pts = [(int(x),int(y)) for x,y in pat_point.findall(m.group(2))]        agents.append(pts)    if not agents:        sys.exit("[ERR] no 'Agent i: ...' lines found in paths file")    return agents# ---------- Normalize lengths ----------def normalize_paths(paths, pad_to=None, only=None, swapxy=False, allow_wait=True):    if only is not None:        paths = paths[:only]    # swap X/Y if required    if swapxy:        paths = [[(y,x) for (x,y) in seq] for seq in paths]    # pad to same length    T = max((len(seq) for seq in paths), default=1)    if pad_to is not None:        T = max(T, pad_to)    norm=[]    for seq in paths:        if not seq:            seq=[(0,0)]        cur = list(seq)        # if waiting isn't allowed and there are repeats, still keep them:        # this viewerは表示用なのでそのまま描く        if len(cur) < T:            cur += [cur[-1]]*(T-len(cur))        else:            cur = cur[:T]        norm.append(cur)    return norm, T# ---------- Plot ----------def visualize(map_file, paths_file, *, obstacles='@', swapxy=False, allow_wait=True,              fps=5, pad_to=None, only=None, show_goals=True, trail=False, save=None):    W,H,obs = load_movingai_map(map_file, obstacles)    raw = load_eecbs_paths(paths_file)    paths, T = normalize_paths(raw, pad_to=pad_to, only=only, swapxy=swapxy, allow_wait=allow_wait)    N = len(paths)    fig, ax = plt.subplots()    ax.set_xlim(0, W); ax.set_ylim(0, H); ax.set_aspect('equal')    ax.invert_yaxis()    ax.set_xticks(range(W)); ax.set_yticks(range(H))    ax.grid(True, which='both', linewidth=0.4, alpha=0.3)    # draw obstacles    for (x,y) in obs:        ax.add_patch(plt.Rectangle((x,y), 1, 1, color='black'))    # agent dots    palette = plt.cm.tab20.colors    dots  = []    trails = []    goals = []    for i in range(N):        c = palette[i % len(palette)]        (x0,y0) = paths[i][0]        d, = ax.plot([x0+0.5],[y0+0.5],'o', ms=8, mec=c, mfc='none', mew=2)        dots.append(d)        if trail:            tline, = ax.plot([],[], '-', lw=1, alpha=0.8, color=c)            trails.append(tline)        if show_goals:            gx,gy = paths[i][-1]            goals.append(ax.plot(gx+0.5, gy+0.5, 's', ms=6, mfc=c, mec='k', mew=0.5, alpha=0.8)[0])    txt = ax.text(0.02, 0.02, "t=0", transform=ax.transAxes, ha='left', va='bottom',                  bbox=dict(facecolor='white', alpha=0.6, edgecolor='none'))    def init():        txt.set_text("t=0")        return dots + trails + goals + [txt]    def update(frame):        for i in range(N):            x,y = paths[i][frame]            dots[i].set_data(x+0.5, y+0.5)            if trail:                xs = [p[0]+0.5 for p in paths[i][:frame+1]]                ys = [p[1]+0.5 for p in paths[i][:frame+1]]                trails[i].set_data(xs, ys)        txt.set_text(f"t={frame}")        return dots + trails + goals + [txt]    interval_ms = 1000.0/max(1,fps)    ani = animation.FuncAnimation(fig, update, frames=T, init_func=init, blit=True,                                  interval=interval_ms, repeat=False)    if save:        # 拡張子で自動判断（.mp4 / .gif など）        ani.save(save)        print(f"[OK] saved animation -> {save}")    else:        plt.show()# ---------- CLI ----------if __name__ == "__main__":    ap = argparse.ArgumentParser(description="Lightweight EECBS visualizer (matplotlib)")    ap.add_argument("--map", required=True, help="MovingAI map file (e.g., ldk2.map)")    ap.add_argument("--paths", required=True, help="EECBS output (Agent i: ...)")    ap.add_argument("--obstacles", default='@', help="Obstacle characters (default: @)")    ap.add_argument("--swapxy", action="store_true", help="Swap (x,y) -> (y,x)")    ap.add_argument("--allow-wait", action="store_true", help="Just visualize waits (default)")    ap.add_argument("--fps", type=int, default=6, help="Frames per second (default: 6)")    ap.add_argument("--pad-to", type=int, default=None, help="Pad all agents to this length")    ap.add_argument("--only", type=int, default=None, help="Show only first N agents")    ap.add_argument("--no-goals", dest="show_goals", action="store_false", help="Hide goal squares")    ap.add_argument("--trail", action="store_true", help="Draw path trails")    ap.add_argument("--save", default=None, help="Save to file (e.g., out.mp4 or out.gif) instead of showing")    args = ap.parse_args()    visualize(args.map, args.paths,              obstacles=args.obstacles, swapxy=args.swapxy, allow_wait=args.allow_wait,              fps=args.fps, pad_to=args.pad_to, only=args.only, show_goals=args.show_goals,              trail=args.trail, save=args.save)